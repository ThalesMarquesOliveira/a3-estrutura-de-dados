package estrutura;

public class ListaEncadeada<E> implements Lista<E> {
   private static class Node<E> {
       final E key;
       Node<E> next;
       Node(E key, Node<E> next){
           this.key = key;
           this.next = next;
       }
   }

   private Node<E>[] table;    // buckets
   private int capacity;       // tamanho do array
   private int size;           // qtde de elementos
   private final float loadFactor;
   private int threshold;      // quando ultrapassar, faz resize

   public ListaEncadeada(){
       this(16, 0.75f);
   }

   public ListaEncadeada(int initialCapacity, float loadFactor){
       this.capacity   = initialCapacity;
       this.loadFactor = loadFactor;
       this.threshold  = (int)(capacity * loadFactor);
       this.table      = new Node[capacity];
   }

   // compressÃ£o do hash para [0..capacity-1]
   private int indexFor(Object key) {
       int h = (key == null ? 0 : key.hashCode());
       h ^= (h >>> 16);
       return (h & 0x7FFFFFFF) % capacity;
   }

   @Override
   public boolean add(E e) {
       if (contains(e)) return false;
       if (size + 1 > threshold) resize();
       int idx = indexFor(e);
       table[idx] = new Node(e, table[idx]);
       size++;
       return true;
   }

   @Override
   public boolean contains(E e) {
       int idx = indexFor(e);
       for (Node<E> n = table[idx]; n != null; n = n.next) {
           if ((e == null && n.key == null) || (e != null && e.equals(n.key))) {
               return true;
           }
       }
       return false;
   }

   @Override
   public boolean remove(E e) {
       int idx = indexFor(e);
       Node<E> prev = null;
       for (Node<E> n = table[idx]; n != null; prev = n, n = n.next) {
           if ((e == null && n.key == null) || (e != null && e.equals(n.key))) {
               if (prev == null) {
                   table[idx] = n.next;
               } else {
                   prev.next = n.next;
               }
               size--;
               return true;
           }
       }
       return false;
   }

   @Override
   public int size(){
       return size;
   }

   @Override
   public void clear(){
       for (int i = 0; i < table.length; i++){
           table[i] = null;
       }
       size = 0;
   }

   // dobra capacidade e re-hasheia todos os elementos
   private void resize(){
       int newCap = capacity * 2;
       Node<E>[] oldTable = table;
       table = new Node[newCap];
       capacity  = newCap;
       threshold = (int)(capacity * loadFactor);
       size = 0;

       for (Node<E> bucket : oldTable){
           for (Node<E> n = bucket; n != null; n = n.next){
               add(n.key);
           }
       }
   }
}
